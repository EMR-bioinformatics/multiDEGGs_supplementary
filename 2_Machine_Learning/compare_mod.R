# ML pipeline
# version 0.6.1
# 15/05/2024
# by Myles Lewis

library(parallel)


#' Compare models
#'
#' Compares `nestedcv` models using repeated nested CV. Outer fold indices are
#' fixed to allow for fair comparison between different model types.
#'
#' @param y Response vector. For classification this should be a factor.
#' @param x Matrix or dataframe of predictors
#' @param models Named list of models to be called. Each list element should
#'   contain 2 elements: `model` and `args`. `model` should be a character value
#'   which can be `"glmnet"`, `"rf"`, `"SL"` or `"SuperLearner"`, or any caret
#'   model available as a `method` in `caret::train()`. `args` is a list of
#'   named arguments which are passed to either [nestcv.glmnet()] if 
#'   `model = "glmnet"`, [nestcv.train()] if model is a caret model method or
#'   `outercv(..., model = "randomForest")` if `model` is set to `"rf"`. If
#'   `model` equals `"SL"` or `"SuperLearner"` arguments are passed to
#'   [nestcv.SuperLearn()].
#' @param grid Optional named list of arguments which can be varied across every
#'   single model. For example different filters or balancing methods can be
#'   tested across all models.
#' @param repeats Number of repeats for each model.
#' @param n_outer_folds Number of outer CV folds
#' @param ofolds List of outer fold indices as generated by
#'   `caret::createFolds()`, one set of outer folds for each repeat.
#' @param verbose Logical whether to print messages.
#' @param rep.cores Integer specifying number of cores/threads to invoke.
#' @param extra Logical whether additional performance metrics are gathered for
#'   binary classification models: area under precision recall curve (AUC.PR),
#'   F1 score, Matthew's correlation coefficient (MCC).
#' @param return_fits Logical whether to return all `nestedcv` model objects.
#' @param ... Additional arguments passed to `nestedcv` models. Can be used to
#'   pass arguments common to all models.
#' @return List of S3 class 'compare_mod' containing:
#' \item{call}{the call}
#' \item{result}{list containing a dataframe of metrics for each model}
#' \item{output}{list containing a dataframe/matrix per model of test 
#' predictions from all repeats}
#' \item{models}{expanded list of models and their arguments}
#' \item{ofolds}{list of outer CV fold indices for each repeat}
#' \item{grid}{grid argument}
#' \item{roc}{optional list containing a `pROC::roc()` object for each model 
#' (binary classification only)}
#' \item{fits}{optional list of lists returned when `return_fits` is `TRUE` 
#' containing `nestcv.*` fitted objects for each repeated model}
#' 
compare_mod <- function(y, x, models,
                        grid = NULL,
                        repeats = 5,
                        n_outer_folds = 10,
                        ofolds = NULL,
                        verbose = TRUE,
                        rep.cores = 1,
                        extra = FALSE,
                        return_fits = FALSE, ...) {
  start <- Sys.time()
  dots <- list(...)
  mcall <- match.call(expand.dots = TRUE)
  
  if (is.data.frame(x)) {
    xnum <- vapply(x, is.numeric, logical(1))
    if (any(!xnum)) message("Non-numeric columns in `x`")
  }
  
  if (Sys.info()["sysname"] == "Windows" & rep.cores > 1) {
    message("'rep.cores' > 1 is not supported on Windows. Set to 1.")
    rep.cores <- 1L
  }
  rstudio <- !is.na(Sys.getenv("RSTUDIO", unset = NA))
  # must turn off all messages to enable forking
  fork <- !rstudio & Sys.info()["sysname"] != "Windows"
  
  if (is.null(ofolds)) {
    ofolds <- lapply(1:repeats, function(i) createFolds(y, k = n_outer_folds))
    names(ofolds) <- paste0("Rep", 1:repeats)
  }
  
  if (!is.list(models)) models <- lapply(models, function(i) list(model = i))
  if (is.null(names(models))) names(models) <- sapply(models, "[[", "model")
  if (!is.null(grid)) models <- expandList(models, grid)
  nm <- names(models)
  nm <- make.unique(nm)
  nmj <- format(nm, justify = "left")
  
  if (verbose & rep.cores >= 2) {
    cv.cores <- dots$cv.cores
    if (is.null(cv.cores)) cv.cores <- 1
    nestedcv:::cat_parallel("Nested cv with ", repeats, " repeats")
    if (cv.cores > 1) {
      nestedcv:::message_parallel(":\n", rep.cores, " cores for repeats x ",
                       cv.cores, " cores for CV = ",
                       rep.cores * cv.cores, " cores total (",
                       parallel::detectCores(logical = FALSE), "-core CPU)")
    } else {
      nestedcv:::message_parallel(" over ", rep.cores, " cores (",
                       parallel::detectCores(logical = FALSE), "-core CPU)")
    }
  }
  
  # disable openMP multithreading (fix for xgboost)
  if (rep.cores >= 2) {
    threads <- RhpcBLASctl::omp_get_max_threads()
    if (!is.na(threads) && threads > 1) {
      RhpcBLASctl::omp_set_num_threads(1L)
      on.exit(RhpcBLASctl::omp_set_num_threads(threads))
    }
  }
  
  output <- lapply(seq_along(models), function(i) {
    ml <- models[[i]]
    m <- ml$model
    title <- nmj[[i]]
    args <- c(list(y = y, x = x, n_outer_folds = n_outer_folds), ml$args, dots)
    verbose <- verbose & !fork
    if (m == "glmnet") {
      args$finalCV <- NA
      res <- rep_metrics("nestcv.glmnet", args, repeats, ofolds, verbose, title,
                     rep.cores, extra, return_fits)
    } else if (m == "rf" | m == "randomForest") {
      args$model <- "randomForest"
      res <- rep_metrics("outercv", args, repeats, ofolds, verbose, title,
                     rep.cores, extra, return_fits)
    } else if (m == "SL" | m == "SuperLearner") {
      args$final <- FALSE
      res <- rep_metrics("nestcv.SuperLearner", args, repeats, ofolds, verbose,
                     title, rep.cores, extra, return_fits)
    } else {
      args$finalCV <- NA
      args$method <- m
      res <- rep_metrics("nestcv.train", args, repeats, ofolds, verbose, title,
                     rep.cores, extra, return_fits)
    }
    
    balance <- if (!is.null(args$balance)) args$balance else "none"
    filter <- if (!is.null(args$filterFUN)) args$filterFUN else "none"
    nfilter <- if (!is.null(args$filter_options$nfilter)) {
      args$filter_options$nfilter
    } else NA
    if (length(nfilter > 1)) nfilter <- sum(nfilter)
    res1 <- data.frame(res[[1]])
    ret <- cbind(model = m, balance, filter, nfilter, res1)
    if (return_fits) return(list(ret, res[[2]], res[[3]]))
    list(ret, res[[2]])
  })
  names(output) <- nm
  
  output1 <- lapply(output, "[[", 1)
  output2 <- lapply(output, "[[", 2)
  
  end <- Sys.time()
  if (verbose) cat("Time", format(end - start, digits = 3), "\n")
  
  out <- list(call = mcall, result = output1, output = output2,
              models = models, ofolds = ofolds, grid = grid)
  if (is.factor(y) && nlevels(y) == 2) {
    out$roc <- lapply(output2, function(i) {
      if (all(is.na(i))) return(NULL)
      pROC::roc(i$testy, i$predyp, direction = "<", quiet = TRUE)
    })
  }
  if (return_fits) out$fits <- lapply(output, "[[", 3)
  
  class(out) <- "compare_mod"
  out
}


summary.compare_mod <- function(object, ...) {
  result <- object$result
  w <- unlist(lapply(result, function(i) is.null(i$res)))
  
  out <- lapply(result[w], function(i) {
    res <- i[, !colnames(i) %in% c("model", "balance", "filter", "nfilter")]
    res <- as.matrix(res)
    sm <- colMeans(res)
    ssd <- matrixStats::colSds(res)
    ssem <- ssd / sqrt(nrow(res))
    
    data.frame(model=i$model[1], balance=i$balance[1], filter=i$filter[1],
               nfilter=i$nfilter[1], metric=colnames(res),
               mean=sm, sd=ssd, sem=ssem,
               row.names = seq_len(ncol(res)))
  })
  if (any(duplicated(names(out)))) names(out) <- make.names(names(out))
  for (i in seq_along(out)) {
    out[[i]]$id <- names(out)[i]
  }
  out <- do.call(rbind, out)
  rownames(out) <- NULL
  out
}


# internal core function for repeated calls to nestcv functions
# converts errors to warnings
rep_metrics <- function(what, args, repeats, ofolds, verbose, title, rep.cores,
                        extra, return_fits, innerCV = FALSE) {
  if (verbose) {
    if (rep.cores == 1) {pb <- txtProgressBar2(title = title)
    } else {
      start <- Sys.time()
      nestedcv:::cat_parallel(title, "  |")
    }
  }
  
  res <- mclapply(seq_len(repeats), function(i) {
    if (verbose & rep.cores > 1 & i %% rep.cores == 1) {
      pc <- round(((i-1) / rep.cores) / ceiling(repeats / rep.cores) * 100)
      if (pc > 0 & pc < 100) nestedcv:::cat_parallel(pc, "%")
      args$verbose <- 2
    } else args$verbose <- 0
    args$outer_folds <- ofolds[[i]]
    fit <- try(do.call(what, args), silent = TRUE)
    if (verbose & rep.cores == 1) setTxtProgressBar(pb, i / repeats)
    if (inherits(fit, "try-error")) {
      out <- list(NA, NA)
      if (verbose) {
        if (rep.cores > 1) nestedcv:::cat_parallel("x")
        attr(out, "error") <- fit[1]
      }
      return(out)
    }
    output <- fit$output
    output$rep <- i
    met <- try(metrics(fit, extra, innerCV), silent = TRUE)
    if (inherits(met, "try-error")) {
      message_parallel("error in `metrics()`")
      message_parallel(class(output))
      message_parallel(paste(dim(output), collapse = " "))
      out <- list(NA, NA)
      attr(out, "error") <- met[1]
      return(out)
    }
    if (return_fits) return(list(met = met, output = output, fit = fit))
    list(met = met, output = output)
  }, mc.cores = rep.cores)
  
  if (verbose) {
    if (rep.cores == 1) {close(pb)
    } else {
      end <- Sys.time()
      nestedcv:::message_parallel("|  (", format(end - start, digits = 3), ")")
    }
    # convert error messages to warnings
    errs <- unique(unlist(lapply(res, function(i) attr(i, "error"))))
    for (i in errs) {
      warning(gsub(" ", "", title), " ", i, call. = FALSE)
    }
  }
  
  # all other models
  res1 <- lapply(res, "[[", 1)
  result <- do.call(rbind, res1)
  res2 <- lapply(res, "[[", 2)
  output <- do.call(rbind, res2)
  fit <- if (return_fits) lapply(res, "[[", 3) else NULL
  
  list(result = result, output = output, fit = fit)
}


# internal function for expanding the arguments lists by grid
expandList <- function(x, y) {
  out <- rep(x, each=length(y))
  for (i in seq_along(x)) {
    for (j in seq_along(y)) {
      w <- (i-1) * length(y) + j
      yname <- names(y[j])
      if (!is.null(out[[w]]$args) && yname %in% names(out[[w]]$args))
        stop("argument already present")
      out[[w]]$args <- c(out[[w]]$args, y[j])
    }
  }
  if (length(x) > 1) {
    names(out) <- paste(names(out), rep(seq_along(y), length(x)), sep=".")
  }
  out
}


plot_modcompare <- function(object,
                            yvar = "AUC", xvar = "model", xvar2 = NULL,
                            type = c("boxplot", "errorbar"),
                            errorbar = c("sd", "sem"),
                            sort_xvar = c("none", "increasing", "decreasing")) {
  if (!inherits(object, "compare_mod"))
    stop("not an object of class 'compare_mod'")
  type <- match.arg(type)
  sort_xvar <- match.arg(sort_xvar)
  errorbar <- match.arg(errorbar)
  result <- object$result
  for (i in names(result)) {
    result[[i]]$id <- i
  }
  w <- unlist(lapply(result, function(i) is.null(i$res)))
  result <- result[w]
  st <- do.call(rbind, result)
  if (!yvar %in% colnames(st)) stop(sprintf("yvar = '%s' not found", yvar))
  
  st[, xvar] <- factor(st[, xvar])
  if (sort_xvar != "none") {
    m <- vapply(result, function(i) {
      mean(i[, yvar], na.rm = TRUE)
    }, numeric(1))
    levs <- unique(st[, xvar])[order(m)]
    st[, xvar] <- if (sort_xvar == "increasing") {
      factor(st[, xvar], levels = levs)
    } else factor(st[, xvar], levels = rev(levs))
  }
  
  if (is.null(xvar2)) {
    if (type == "boxplot") {
      ggplot(st, aes(x=.data[[xvar]], y=.data[[yvar]])) +
        geom_jitter(aes(col=.data[[xvar]]), width=0.08,
                    show.legend = FALSE) +
        scale_colour_hue(l = 70) +
        geom_boxplot(outlier.shape = NA, alpha = 0) +
        theme_classic() +
        theme(axis.text = element_text(colour = "black"),
              axis.text.x = element_text(angle = 45, hjust=1))
    } else {
      # plot mean + errorbars
      dfstat <- st %>% 
        dplyr::group_by(across(xvar)) %>%
        dplyr::summarise_at(vars(yvar), list(mean=mean, sd=sd, sem=sem)) %>%
        as.data.frame
      
      ggplot(dfstat, aes(x = .data[[xvar]], y = .data$mean,
                         col = .data[[xvar]])) +
        geom_errorbar(aes(ymin = .data$mean - .data[[errorbar]],
                          ymax = .data$mean + .data[[errorbar]]),
                      width = 0.1, show.legend = FALSE) +
        geom_point(size = 3, show.legend = FALSE) +
        ylab(yvar) +
        theme_classic() +
        theme(axis.text = element_text(colour = "black"),
              axis.text.x = element_text(angle = 45, hjust=1))
    }
  } else {
    # with 2nd grouping variable
    if (type == "boxplot") {
    st[, xvar2] <- factor(st[, xvar2])
    ggplot(st, aes(x = .data[[xvar]], y = .data[[yvar]], col = .data[[xvar2]])) +
      geom_point(position = position_jitterdodge(jitter.width = 0.05)) +
      geom_boxplot(outlier.shape = NA, alpha = 0) +
      scale_colour_hue(l = 70) +
      theme_classic() +
      theme(axis.text = element_text(colour = "black"),
            axis.text.x = element_text(angle = 45, hjust=1))
    } else {
      # plot mean + errorbars
      dfstat <- st %>% 
        dplyr::group_by(across(c(xvar, xvar2))) %>%
        dplyr::summarise_at(vars(yvar), list(mean=mean, sd=sd, sem=sem)) %>%
        as.data.frame
      
      pd <- position_dodge(0.7)
      ggplot(dfstat, aes(x = .data[[xvar]], y = .data$mean,
                         col = .data[[xvar2]])) +
        geom_errorbar(aes(ymin = .data$mean - .data[[errorbar]],
                          ymax = .data$mean + .data[[errorbar]]),
                      width = 0.4, position = pd,
                      show.legend = FALSE) +
        geom_point(position = pd, size = 2) +
        ylab(yvar) +
        theme_classic() +
        theme(axis.text = element_text(colour = "black"),
              axis.text.x = element_text(angle = 45, hjust=1))
    }
  }
}

sem <- function(x) sd(x, na.rm = TRUE) / sqrt(sum(!is.na(x)))

removeAC <- function(x) {
  grepl("^[A-Z]{2}[0-9]{6}", colnames(x))
}
